input {
  tcp {
    port => 5000
  }
  beats {
    port => 5044
  }
}

## Add your filters / logstash plugins configuration here
filter {
  grok {
    match => {
      "message" => "%{LOCALDATETIME:postgresql.log.timestamp} %{WORD:event.timezone} \[%{NUMBER:process.pid:long}(-%{BASE16FLOAT:postgresql.log.core_id:long})?\] ((\[%{USERNAME:user.name}\]@\[%{POSTGRESQL_DB_NAME:postgresql.log.database}\]|%{USERNAME:user.name}@%{POSTGRESQL_DB_NAME:postgresql.log.database}|@) )?%{WORD:log.level}:  %{GREEDYDATA:tmp.postgres_message}"
    }
    pattern_definitions => {
      "LOCALDATETIME" => "[-0-9]+ %{TIME}"
      "POSTGRESQL_DB_NAME" => "[a-zA-Z0-9_]+[a-zA-Z0-9_\$]*"
    }
  }
  grok {
    match => {
      "tmp.postgres_message" => [
        "duration: %{NUMBER:tmp.duration:float} ms  (%{WORD:postgresql.log.type}).*?: %{GREEDYDATA:postgresql.log.query}\n.*parameters:",
        "(duration: %{NUMBER:tmp.duration:float} ms  (%{WORD:postgresql.log.type}).*?: %{GREEDYDATA:postgresql.log.query}|{%{GREEDYDATA:postgresql.log.not_parsed_message})"
      ]
    }
  }
  grok {
    match => {
      "tmp.postgres_message" => "parameters: %{GREEDYDATA:postgresql.log.parameters}"
    }
    tag_on_failure => []
  }
  date {
    match => [
      "postgresql.log.timestamp", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm:ss.SSS"
    ]
  }
  ruby {
    code => "
      if event.get('tmp.duration')
        event.set('event.duration',event.get('tmp.duration')*1000000)
      else
         event.set('event.duration',0)
      end
      "
  }
  mutate {
    remove_field => ["tmp.postgres_message", "tmp.duration"]
  }
}

output {
	elasticsearch {
		hosts => "elasticsearch:9200"
    manage_template => false
    index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
	}
}
